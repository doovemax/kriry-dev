# FAQ

## Riker的目标是什么？

Riker的主要目标是成为一个框架，使并发，弹性软件开发变得容易，并使Actor模型适用于广泛的平台。

Riker通过以下方式达到此目的：

* 暴露一个简单的`Actor`特质
* 基于actor层次结构的Actor监督
* 允许Actors拥有自己的状态，因此不需要Sync
* 确保“最多一次”的消息保证
* 提供可配置的模块化系统
* 促进基于事件的现代数据持久性
* 内存占用少
* 快速执行
* 没有不安全的代码（impl Send和impl Sync除外）

Riker是翻拍Akka的Rust吗？

Riker的灵感来自于JVM广受欢迎的Actor Model实现[Akka](https://akka.io/)。然而，Riker的目标不是为Rust重新创建Akka。其他环境已经做到了这一点，例如`C＃`的`Akka.NET`，但Rust和Scala / Java等的差异需要一种新的特定于Rust的方法。由于Riker在资源有限的硬件（如单板计算机）上运行良好，因此需要解决的新挑战和问题不适用于Akka。

## `Actor`如何与`Future`相比？

Actors和Futures一般都致力于解决并发软件设计的挑战。然而，他们是免费的，因为他们正在解决不同的问

Futures允许软件开发人员以几乎单线程的方式编写并发代码。可以轻松编写非阻塞的简单，短暂的工作负载处理。因此，Futures可被视为非阻塞应用程序设计的构建块。

另一方面，在状态存在时使用Actor，并且必须在actor运行和空闲时的周期之间保持。 Actor非常适合长时间运行的进程，甚至可以跨越应用程序本身的生命周期。`Actor`还与父级和子级`Actor`形成一个层次结构，通过基于消息的API相互通信。由于`Actor`知道系统中的其他`Actor`，他们可以在意外事件发生时相互治愈，例如恐慌。

在幕后，Riker actor是Futures并在底层线程池中作为Futures运行。

## `Actor`如何与线程比较？

`Actor`只有在其邮箱中有一条或多条邮件时才会运行并使用CPU线程。当`Actor`被发送一条消息，该`Actor`被安排执行。当线程可用时，将actor及其状态转移（即发送）给线程，并且actor处理其消息（即调用接收方法）。只有这样，`Actor`才会使用任何OS线程资源。当一个actor空闲时，它不需要线程执行时间。

拥有数千或数百万只只占用两个CPU核心/线程的角色是可能的。

## Riker可以在多个主机上运行吗？

与任何应用程序一样，Riker应用程序可以轻松地分布在多个网络主机或Docker容器中。应用程序可以使用简单的负载平衡进行负载平衡，或者使用[Kubernetes](https://kubernetes.io/)，[Linkerd](https://linkerd.io/)等构成更复杂系统的一部分。

只有当应用程序使用Riker的CQRS功能时，才应考虑使用其他体系结构设计来管理实体。在CQRS环境中，确保只有一个实体actor实例跨多个主机运行至关重要。 Riker Cluster目前正在开发中，以实现此协调。

## 多个ActorSystem实例可以在同一个应用程序中运行吗？

可以使用ActorSystem :: new创建两个或更多实例，但这样做没什么好处。单个实例已经过优化，可以在配置的调度程序上运行actor，该调度程序通常使用CPU的所有内核。

此建议的一个例外是当应用程序处理大大不同的工作负载时，由于体系结构限制而无法分解为多个应用程序。

## Riker是否使用不安全的代码？

Riker不会对任何内存管理使用不安全。我们认为使用借用检查器和编译器比使用它们更好。

unsafe仅用于将一些类型显式标记为Send或Sync以帮助编译器。这两个都有空实现，即没有实际的不安全代码：

```rust
unsafe impl<T: Message> Send for Envelope<T> {}
```

## 有没有基准？

我们正在努力尽快提供共同的行动者基准。 我们希望确保我们使用的基准实际上对现实场景有意义。 就纯消息吞吐量而言，一个参与者到另一个参与者，在标准的2018笔记本电脑上每秒可以发送数百万条消息。